// Test for complex generic templates with multiple features
// This test combines several language features to test semantic depth and breadth

Container: <T> type = {
    data: std::vector<T> = ();
    
    // Constructor
    Container: (initial_size: i32) = {
        data.resize(initial_size);
    }
    
    // Template member function
    add: (value: T) = {
        data.push_back(value);
    }
    
    // Generic function in class
    get_at: <IndexType> (idx: IndexType) -> T& = {
        return data[cpp2::as_<i32>(idx)];
    }
    
    // Return function with forwarding
    size: () -> i32 = {
        return cpp2::as_<i32>(data.size());
    }
    
    // Function with multiple template parameters
    fill_with_func: <Func, U> (func: Func, count: i32, initial: U) = {
        i: i32 = 0;
        while i < count {
            add(func(initial, i));
            i++;
        }
    }
    
    // Function with constraints
    sort_if_comparable: <U = T> (this) requires std::totally_ordered<U> = {
        std::sort(data.begin(), data.end());
    }
}

// Generic function with constraints
process_container: <T> (c: inout Container<T>) = {
    std::cout << "Processing container with " << c.size() << " elements\n";
    
    // Using inspect expression with templates
    inspect c.size() {
        is 0 => std::cout << "Empty container\n";
        is n if n < 5 => std::cout << "Small container: " << n << " elements\n";
        is n => std::cout << "Large container: " << n << " elements\n";
    }
    
    // Using generic lambda
    printer := :(const ref x: T) -> void = {
        std::cout << "Element: " << x << "\n";
    };
    
    // Iterate and apply function
    for elem : c.data {
        printer(elem);
    }
}

// Higher-order function
apply_operation: <T, Op> (value: T, op: Op) -> T = {
    return op(value);
}

// Function with multiple return values
split_string: (input: std::string) -> (std::string, std::string) = {
    pos := input.find(' ');
    if pos != std::string::npos {
        return (input.substr(0, pos), input.substr(pos + 1));
    }
    else {
        return (input, "");
    }
}

// Function with contracts
safe_divide: (num: f64, den: f64) -> f64 = {
    _pre: (den != 0) = "Denominator cannot be zero";
    _post: (ret) = "Result should be finite" requires std::isfinite(ret);
    
    return num / den;
}

main: () -> int = {
    // Test basic container
    cont: Container<int> = (5);
    i: i32 = 0;
    while i < 5 {
        cont.add(i * 2);
        i++;
    }
    
    std::cout << "Container size: " << cont.size() << "\n";
    
    // Test generic function in class
    val := cont.get_at(2);
    std::cout << "Value at index 2: " << val << "\n";
    
    // Test complex generic function
    cont.fill_with_func(
        :(x: int, i: i32) -> int = { return x + i; },  // Generic lambda
        3,  // count
        10  // initial value
    );
    
    std::cout << "New container size after fill: " << cont.size() << "\n";
    
    // Test higher-order function
    square := :(x: int) -> int = { return x * x; };
    result := apply_operation(5, square);
    std::cout << "Square of 5: " << result << "\n";
    
    // Test multiple return values
    (first, second) := split_string("hello world");
    std::cout << "First: '" << first << "', Second: '" << second << "'\n";
    
    // Test contracts
    try {
        result2 := safe_divide(10.0, 2.0);
        std::cout << "10/2 = " << result2 << "\n";
        
        // This should fail the precondition
        result3 := safe_divide(10.0, 0.0);
        std::cout << "10/0 = " << result3 << "\n";
    }
    catch _ {
        std::cout << "Caught division by zero exception\n";
    }
    
    // Test process_container function
    process_container(cont);
    
    return 0;
}